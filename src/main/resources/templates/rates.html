<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>KRW 기준 환율</title>
    <style>
        :root{--bg:#0B1221;--panel:#0F172A;--text:#D1D5DB;--muted:#9CA3AF;--up:#10B981;--down:#EF4444;--grid:rgba(255,255,255,.06);--accent:#2563EB}
        html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
        .wrap{display:grid;grid-template-columns:320px 1fr;gap:16px;height:100%;box-sizing:border-box;padding:16px}
        .panel{background:var(--panel);border-radius:16px;padding:16px;display:flex;flex-direction:column;gap:16px;box-shadow:0 6px 24px rgba(0,0,0,.2)}
        .panel h2{margin:0 0 8px;font-size:18px}
        .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
        label{font-size:12px;color:var(--muted)}
        select{background:#0b1221;color:var(--text);border:1px solid #1F2937;border-radius:10px;padding:8px 10px;outline:none;width:100%}
        .chart-card{background:var(--panel);border-radius:16px;padding:12px;height:100%;display:flex;flex-direction:column;box-shadow:0 6px 24px rgba(0,0,0,.2);position:relative}
        #chart-area{flex:1;min-height:560px;border-radius:12px;position:relative}
        #status{font-size:12px;color:var(--muted);margin-top:6px;min-height:16px;white-space:pre-line}
        .pair-title{font-size:16px;font-weight:600;display:flex;align-items:baseline;gap:8px}
        .last-quote{font-size:14px}
        .hint{font-size:12px;color:var(--muted)}
        .divider{height:1px;background:#1F2937;margin:8px 0}
        .tf-inside{position:absolute;left:16px;top:16px;display:flex;gap:6px;z-index:10;background:rgba(11,18,33,.6);backdrop-filter:blur(6px);padding:6px;border-radius:12px;border:1px solid #1F2937}
        .tf-btn{background:#111827;color:var(--text);border:1px solid #1F2937;border-radius:999px;padding:6px 10px;cursor:pointer;font-size:12px}
        .tf-btn.active{border-color:var(--accent);box-shadow:0 0 0 2px rgba(37,99,235,.25) inset}
        @media (max-width:900px){.wrap{grid-template-columns:1fr}}
    </style>

    <!-- Lightweight Charts 폴백 로더 -->
    <script>
        (function () {
          const cdn = (v, f) => `https://cdn.jsdelivr.net/npm/lightweight-charts@${v}/dist/${f}`;
          const unp = (v, f) => `https://unpkg.com/lightweight-charts@${v}/dist/${f}`;
          const versions = ["4.3.0","4"];
          const files = [
            "lightweight-charts.standalone.production.min.js",
            "lightweight-charts.standalone.production.js",
            "lightweight-charts.standalone.development.js",
          ];
          const candidates = [];
          versions.forEach(v => files.forEach(f => candidates.push(cdn(v,f))));
          versions.forEach(v => files.forEach(f => candidates.push(unp(v,f))));
          window.__loadLwc = () =>
            new Promise((resolve, reject) => {
              let i=0;
              const tryNext=()=>{
                if(i>=candidates.length) return reject(new Error("Lightweight Charts 로드 실패"));
                const url=candidates[i++], s=document.createElement("script");
                s.src=url; s.async=true;
                s.onload=()=>{
                  const L=window.LightweightCharts;
                  if(!L?.createChart){ s.remove(); tryNext(); return; }
                  const tmp=document.createElement("div"); document.body.appendChild(tmp);
                  try{
                    const c=L.createChart(tmp);
                    if(typeof c?.addCandlestickSeries!=="function"){ s.remove(); c?.remove?.(); tmp.remove(); tryNext(); return; }
                    c.remove(); tmp.remove(); resolve();
                  }catch{ s.remove(); tmp.remove(); tryNext(); }
                };
                s.onerror=tryNext; document.head.appendChild(s);
              };
              tryNext();
            });
        })();
    </script>
</head>
<body>
<div class="wrap">
    <aside class="panel">
        <div>
            <h2>설정</h2>
            <div class="row" style="margin-top:8px;">
                <div style="display:flex;flex-direction:column;gap:6px;min-width:100%;">
                    <label for="pair">통화 쌍 (기준단위 → KRW)</label>
                    <select id="pair">
                        <option value="USD/KRW" selected>원달러환율 (1 USD → KRW)</option>
                        <option value="JPY/KRW">원엔화환율 (100 JPY → KRW)</option>
                        <option value="CNY/KRW">원위안환율 (100 CNY → KRW)</option>
                        <option value="EUR/KRW">원유로환율 (1 EUR → KRW)</option>
                        <option value="GBP/KRW">원파운드환율 (1 GBP → KRW)</option>
                    </select>
                </div>
            </div>

            <div class="divider"></div>
            <div class="pair-title">
                <span id="pair-label">원달러환율 (USD/KRW)</span>
                <span class="last-quote" id="last-quote"></span>
            </div>
            <div class="hint">※ 백엔드는 <b>XXX/KRW</b>로 조회. 엔/위안은 <b>100 단위</b>로 환산.</div>
            <div id="status"></div>
        </div>
    </aside>

    <main class="chart-card">
        <div id="chart-area">
            <div class="tf-inside" id="tf-inside">
                <button class="tf-btn" data-tf="1s">1초</button>
                <button class="tf-btn active" data-tf="1m">1분</button>
                <button class="tf-btn" data-tf="15m">15분</button>
                <button class="tf-btn" data-tf="30m">30분</button>
                <button class="tf-btn" data-tf="1h">1시간</button>
                <button class="tf-btn" data-tf="4h">4시간</button>
                <button class="tf-btn" data-tf="1d">1일</button>
                <button class="tf-btn" data-tf="1w">1주</button>
                <button class="tf-btn" data-tf="1M">1개월</button>
            </div>
        </div>
    </main>
</div>

<script>
    // ====== 상수 & 유틸 ======
    const $ = (id) => document.getElementById(id);
    const PRICE_PREC = 2;
    const KST_OFFSET = 9*3600; // seconds
    const toKstSec = (utcSec)=> utcSec + KST_OFFSET;
    const toUtcSec = (kstSec)=> kstSec - KST_OFFSET;
    const fmt2 = (n)=> Number(n).toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});
    const minMove = Math.pow(10,-PRICE_PREC);

    const PAIR_CFG = {
      'USD/KRW': { title:'원달러환율',  basis:1,   basisLabel:'1 USD',  seed:1350 },
      'JPY/KRW': { title:'원엔화환율',  basis:100, basisLabel:'100 JPY', seed:900  },
      'CNY/KRW': { title:'원위안환율',  basis:100, basisLabel:'100 CNY', seed:19000},
      'EUR/KRW': { title:'원유로환율',  basis:1,   basisLabel:'1 EUR',  seed:1450 },
      'GBP/KRW': { title:'원파운드환율', basis:1,   basisLabel:'1 GBP',  seed:1750 },
    };

    const AUTO_LIMIT = (tf) => ({
      '1s': 900,
      '1m': 720,
      '15m':800,
      '30m':800,
      '1h': 900,
      '4h': 800,
      '1d': 1000,
      '1w': 800,
      '1M': 600
    }[tf] ?? 900);

    const TF_UNIT_SEC = (tf) => ({
      '1s':1, '1m':60, '15m':900, '30m':1800, '1h':3600, '4h':14400
    }[tf] ?? null);

    function tickMarkKSTFormatterFactory(currentTf) {
      return (time) => {
        const d = new Date((time + KST_OFFSET) * 1000);
        const y = d.getUTCFullYear();
        const M = String(d.getUTCMonth()+1).padStart(2,'0');
        const D = String(d.getUTCDate()).padStart(2,'0');
        const h = String(d.getUTCHours()).padStart(2,'0');
        const m = String(d.getUTCMinutes()).padStart(2,'0');
        const s = String(d.getUTCSeconds()).padStart(2,'0');
        if (currentTf === '1s') return `${h}:${m}:${s}`;
        if (currentTf === '1m' || currentTf === '15m' || currentTf === '30m' || currentTf === '1h' || currentTf==='4h') return `${M}/${D} ${h}:${m}`;
        if (currentTf === '1w' || currentTf === '1M') return `${y}-${M}-${D}`;
        return `${y}-${M}-${D}`;
      };
    }

    function floorToTfStartKst(kstSec, tf) {
      const unit = TF_UNIT_SEC(tf);
      if (unit) return kstSec - (kstSec % unit);

      const dayStart = kstSec - (kstSec % 86400);
      if (tf === '1d') return dayStart;

      if (tf === '1w') {
        const dow = new Date((toUtcSec(kstSec))*1000).getUTCDay(); // 0=일
        const daysFromMon = (dow + 6) % 7; // 월=0
        return dayStart - daysFromMon*86400;
      }

      if (tf === '1M') {
        const k = new Date((toUtcSec(kstSec))*1000);
        const y = k.getUTCFullYear();
        const m = k.getUTCMonth();
        const firstOfMonthKst = Date.UTC(y, m, 1, 0,0,0) + KST_OFFSET*1000;
        return Math.floor(firstOfMonthKst/1000);
      }
      return kstSec;
    }

    function nextTfStartKst(fromKstStart, tf) {
      const unit = TF_UNIT_SEC(tf);
      if (unit) return fromKstStart + unit;
      if (tf === '1d') return fromKstStart + 86400;
      if (tf === '1w') return fromKstStart + 7*86400;
      if (tf === '1M') {
        const k = new Date((toUtcSec(fromKstStart))*1000);
        const y = k.getUTCFullYear();
        const m = k.getUTCMonth();
        const next = Date.UTC(m===11?y+1:y, (m+1)%12, 1, 0,0,0) + KST_OFFSET*1000;
        return Math.floor(next/1000);
      }
      return fromKstStart;
    }

    // ====== IndexedDB 캐시 ======
    const LocalOHLCStore = (()=> {
      let dbp = null;
      function open() {
        if (dbp) return dbp;
        dbp = new Promise((resolve, reject)=>{
          const req = indexedDB.open('fx-cache', 1);
          req.onupgradeneeded = () => {
            const db = req.result;
            if (!db.objectStoreNames.contains('candles')) {
              db.createObjectStore('candles', { keyPath: 'key' });
            }
          };
          req.onsuccess = ()=> resolve(req.result);
          req.onerror = ()=> reject(req.error);
        });
        return dbp;
      }
      async function get(key) {
        try {
          const db = await open();
          return await new Promise((res, rej)=>{
            const tx = db.transaction('candles','readonly');
            const st = tx.objectStore('candles');
            const rq = st.get(key);
            rq.onsuccess = ()=> res(rq.result || null);
            rq.onerror = ()=> rej(rq.error);
          });
        } catch { return null; }
      }
      async function set(key, value) {
        try {
          const db = await open();
          return await new Promise((res, rej)=>{
            const tx = db.transaction('candles','readwrite');
            const st = tx.objectStore('candles');
            st.put({ key, ...value });
            tx.oncomplete = ()=> res(true);
            tx.onerror = ()=> rej(tx.error);
          });
        } catch { /* ignore */ }
      }
      return { get, set };
    })();

    const pack = (bars)=> bars.map(b=>[b.time,b.open,b.high,b.low,b.close]);
    const unpack = (rows)=> rows.map(a=>({time:a[0],open:a[1],high:a[2],low:a[3],close:a[4]}));

    // ====== 정렬/보정 ======
    function normalizeToKstSlots(bars, tf) {
      // 1) 시간 스냅(KST 슬롯 시작시각으로)
      const snapped = bars.map(b=>{
        const tK = toKstSec(b.time);
        const slotK = floorToTfStartKst(tK, tf);
        return { time: toUtcSec(slotK), open:b.open, high:b.high, low:b.low, close:b.close };
      });

      // 2) 시간순 정렬
      snapped.sort((a,b)=>a.time-b.time);

      // 3) 타임칸 중복 병합(첫 open, 마지막 close, high=max, low=min)
      const merged = [];
      for (const b of snapped) {
        const last = merged[merged.length-1];
        if (last && last.time === b.time) {
          last.high = Math.max(last.high, b.high);
          last.low  = Math.min(last.low,  b.low);
          last.close = b.close;
        } else {
          merged.push({...b});
        }
      }

      // 4) 갭 채우기(이전 종가로 홀더 캔들)
      const filled = [];
      const unit = TF_UNIT_SEC(tf) || (tf==='1d'?86400:(tf==='1w'?7*86400:(tf==='1M'?2629800:60)));
      let i = 0;
      while (i < merged.length) {
        const cur = merged[i];
        filled.push(cur);
        const next = merged[i+1];
        if (next) {
          let expect = cur.time + unit;
          while (expect < next.time) {
            const prevClose = filled[filled.length-1].close;
            filled.push({ time: expect, open:prevClose, high:prevClose, low:prevClose, close:prevClose });
            expect += unit;
          }
        }
        i++;
      }

      // 5) 미래(아직 시작되지 않은 슬롯) 제거
      const nowK = Math.floor(Date.now()/1000) + KST_OFFSET;
      const currentStartK = floorToTfStartKst(nowK, tf);
      const currentStartUtc = toUtcSec(currentStartK);
      const safe = filled.filter(b => b.time <= currentStartUtc);

      return safe;
    }

    // ====== 서버 통신 ======
    const TF_BACKEND = {
      '1s': ['1m'],
      '1m': ['1m','60'],
      '15m':['15m'],
      '30m':['30m'],
      '1h': ['1h','60m'],
      '4h': ['4h','240m'],
      '1d': ['1day','1d','D','day'],
      '1w': ['1week','1w','W','week'],
      '1M': ['1month','1M','M','month'],
    };

    async function fetchCandlesFromBackend(apiPair, tf, limit) {
      const tried = [];
      const plan = [Math.min(limit, 900), 480, 240, 120].filter((v,i,a)=>v>0 && a.indexOf(v)===i);
      const tfs = TF_BACKEND[tf] ?? [tf];
      let lastErr = null;

      for (const lc of plan) {
        for (const t of tfs) {
          tried.push(`${t}/${lc}`);
          try {
            const url = `/api/td-candles?pair=${encodeURIComponent(apiPair)}&tf=${encodeURIComponent(t)}&limit=${lc}`;
            const res = await fetch(url);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const body = await res.json();
            const vals = Array.isArray(body?.values) ? body.values : [];
            if (vals.length) return vals;
            lastErr = new Error('empty');
          } catch (e) { lastErr = e; }
        }
      }
      const statusEl = $('status');
      if (statusEl) statusEl.textContent = `백엔드 오류(가상/캐시 사용): ${lastErr?.message||'fail'}\n시도: ${tried.join(', ')}`;
      throw lastErr || new Error('fetch failed');
    }

    function parseCandles(values){
      return values.map(it=>{
        const t=(it.datetime||it.date||it.time);
        const utcSec = Math.floor(new Date((t && t.endsWith('Z')) ? t : (t+'Z')).getTime()/1000);
        return { time: utcSec, open:+it.open, high:+it.high, low:+it.low, close:+it.close };
      });
    }

    function applyBasis(cs, units){
      if(units===1) return cs;
      return cs.map(c=>({ time:c.time,
        open:c.open*units, high:c.high*units, low:c.low*units, close:c.close*units }));
    }

    // ====== 가상 시드/라이브 ======
    function volatilityFor(tf){
      return ({
        '1s': 0.00020, '1m':0.00015, '15m':0.00025, '30m':0.00030,
        '1h': 0.00040, '4h':0.00060, '1d':0.00120, '1w':0.00200, '1M':0.00350
      }[tf] ?? 0.0003);
    }

    function buildSyntheticHistory(startPrice, tf, bars){
      const out = [];
      const nowKst = Math.floor(Date.now()/1000) + KST_OFFSET;
      const endKst = floorToTfStartKst(nowKst, tf);
      const unit = TF_UNIT_SEC(tf) || (tf==='1d'?86400:(tf==='1w'?7*86400:(tf==='1M'?2629800:60)));
      const sigma = Math.max(startPrice * volatilityFor(tf), 0.01);
      let close = startPrice;
      for (let i=bars-1; i>=0; i--){
        const tKst = endKst - i*unit;
        const tUtc = toUtcSec(tKst);
        const open = close;
        const step = (Math.random()*2-1)*sigma;
        close = Math.max(0.01, open + step);
        const high = Math.max(open, close) + Math.random()*sigma*0.5;
        const low  = Math.min(open, close) - Math.random()*sigma*0.5;
        out.push({ time:tUtc, open, high, low, close });
      }
      return out;
    }

    let chart, candleSeries, resizeObs, pseudoTimer=null;

    function ensureChart(currentTf){
      const L=window.LightweightCharts, statusEl=$('status');
      if(!L?.createChart){ statusEl.textContent='LightweightCharts 로드 실패'; return false; }
      if(!chart){
        const cont=$('chart-area');
        chart=L.createChart(cont,{
          layout:{ textColor:'#D1D5DB', background:{ type:'solid', color:'#0B1221' } },
          grid:{ vertLines:{ color:'rgba(255,255,255,0.06)' }, horzLines:{ color:'rgba(255,255,255,0.06)' } },
          timeScale:{
            timeVisible:true,
            secondsVisible: currentTf === '1s',
            borderVisible:false,
            tickMarkFormatter: tickMarkKSTFormatterFactory(currentTf),
          },
          rightPriceScale:{ borderVisible:false },
          crosshair:{ mode:0 },
          localization: { locale: 'ko-KR' },
        });
      } else {
        chart.applyOptions({
          timeScale:{
            timeVisible:true,
            secondsVisible: currentTf === '1s',
            borderVisible:false,
            tickMarkFormatter: tickMarkKSTFormatterFactory(currentTf),
          },
        });
      }
      if(!candleSeries){
        candleSeries=chart.addCandlestickSeries({
          upColor:'#10B981', downColor:'#EF4444',
          borderUpColor:'#10B981', borderDownColor:'#EF4444',
          wickUpColor:'#10B981', wickDownColor:'#EF4444',
          priceFormat:{ type:'price', precision:PRICE_PREC, minMove:minMove }
        });
      } else {
        candleSeries.applyOptions({ priceFormat:{ type:'price', precision:PRICE_PREC, minMove:minMove } });
      }
      if(!resizeObs){
        const cont=$('chart-area');
        resizeObs=new ResizeObserver(()=>{ try{ chart.timeScale().fitContent(); }catch{} });
        resizeObs.observe(cont);
      }
      return true;
    }

    function stopPseudoLive(){ if(pseudoTimer){ clearInterval(pseudoTimer); pseudoTimer=null; } }

    function startPseudoLive(dataRef, pair, tf, cacheKey, maxBars){
      stopPseudoLive();
      if(!dataRef?.length || !candleSeries) return;

      const vol = volatilityFor(tf);
      const tickMs = (tf==='1s') ? 250 : 1000;
      const cfg = PAIR_CFG[pair] || { basisLabel:'기준' };

      let series = dataRef; // 원본 배열을 계속 업데이트
      const nowK = Math.floor(Date.now()/1000) + KST_OFFSET;
      let curStartK = floorToTfStartKst(nowK, tf);
      let curStartUtc = toUtcSec(curStartK);

      let bar = series[series.length-1];
      if (bar.time < curStartUtc) {
        const open = bar.close;
        bar = { time: curStartUtc, open, high:open, low:open, close:open };
        series.push(bar);
        candleSeries.update(bar);
      } else {
        bar = { ...bar };
      }
      let lastClose = bar.close;

      let lastSavedSlot = bar.time;

      pseudoTimer=setInterval(async ()=> {
        try{
          // 경계 보정(탭 비활성 등으로 누락 방지)
          let nowKst = Math.floor(Date.now()/1000) + KST_OFFSET;
          let nextK = nextTfStartKst(curStartK, tf);
          let guard = 0;
          while (nowKst >= nextK && guard++ < 10) {
            // 이전 바 완성 -> 캐시에 저장될 데이터가 됨
            const open = lastClose;
            curStartK = nextK;
            curStartUtc = toUtcSec(curStartK);
            bar = { time: curStartUtc, open, high: open, low: open, close: open };
            series.push(bar);
            if (series.length > maxBars) series = series.slice(series.length - maxBars);
            candleSeries.update(bar);
            nextK = nextTfStartKst(curStartK, tf);

            // write-behind 저장(슬롯 넘어갈 때만)
            if (cacheKey && lastSavedSlot !== bar.time) {
              lastSavedSlot = bar.time;
              const safe = normalizeToKstSlots(series, tf).slice(-maxBars);
              await LocalOHLCStore.set(cacheKey, { updatedAt: Date.now(), bars: pack(safe) }).catch(()=>{});
            }
          }

          // 현재 진행중 바를 랜덤 워크로 흔들기
          const sigma = Math.max(lastClose * vol, 0.01);
          const step = (Math.random()*2 - 1) * sigma;
          const close = Math.max(0.01, lastClose + step);
          bar.high = Math.max(bar.high, close);
          bar.low  = Math.min(bar.low,  close);
          bar.close = close;
          lastClose = close;

          candleSeries.update(bar);
          $('last-quote').textContent = `${cfg.basisLabel} ≈ ${fmt2(bar.close)} KRW`;
          $('status').textContent = `실시간 표시(캐시/가상): ${pair} • ${tf}`;
        }catch{}
      }, tickMs);
    }

    // ====== 로드 & 전환 ======
    async function loadChart(pair, tf){
      const statusEl=$('status'), lastEl=$('last-quote'), labelEl=$('pair-label');
      const cfg=PAIR_CFG[pair]; if(!cfg){ statusEl.textContent='지원하지 않는 통화'; return; }
      const limit = AUTO_LIMIT(tf);
      const cacheKey = `${pair}|${tf}`;

      labelEl.textContent=`${cfg.title} (${pair})`;
      statusEl.textContent='불러오는 중…'; lastEl.textContent='';

      if(!ensureChart(tf)) return;
      stopPseudoLive();

      // 1) 캐시 먼저: 즉시 표시
      let cached = await LocalOHLCStore.get(cacheKey);
      let data = [];
      if (cached?.bars?.length) {
        data = unpack(cached.bars);
        data = normalizeToKstSlots(data, tf).slice(-limit);
        candleSeries.setData(data);
        chart.timeScale().fitContent();
        const last=data[data.length-1].close;
        $('last-quote').textContent=`${cfg.basisLabel} ≈ ${fmt2(last)} KRW`;
        statusEl.textContent=`캐시 로드: ${pair} • ${tf} • ${data.length}개`;
      }

      // 2) 서버 시도 → 성공 시 캐시와 병합 후 갱신
      let serverOK = false;
      try {
        const raw = await fetchCandlesFromBackend(pair, tf, limit);
        const base = parseCandles(raw);                 // UTC
        let srv = applyBasis(base, cfg.basis);          // 엔/위안 ×100
        srv = normalizeToKstSlots(srv, tf).slice(-limit);

        // 캐시와 병합(단순 합집합 → 정규화)
        const merged = normalizeToKstSlots([...(data||[]), ...srv], tf).slice(-limit);

        if (!data.length || merged[merged.length-1].time !== (data[data.length-1]?.time) || merged[merged.length-1].close !== (data[data.length-1]?.close)) {
          candleSeries.setData(merged);
          chart.timeScale().fitContent();
          data = merged;
        }

        await LocalOHLCStore.set(cacheKey, { updatedAt: Date.now(), bars: pack(data) }).catch(()=>{});
        serverOK = true;

        const last=data[data.length-1].close;
        $('last-quote').textContent=`${cfg.basisLabel} ≈ ${fmt2(last)} KRW`;
        statusEl.textContent=`완료: ${pair} • ${tf} • ${data.length}개 (서버/캐시 병합)`;
      } catch (e) {
        if (!data.length) {
          // 캐시도 없으면 가상 시드
          data = buildSyntheticHistory(cfg.seed || 1000, tf, Math.max(60, Math.min(limit, 600)));
          candleSeries.setData(data);
          chart.timeScale().fitContent();
          statusEl.textContent = `백엔드 오류 → 가상 데이터로 전환 (${e?.message||'unknown'})`;
        } else {
          statusEl.textContent += `\n서버 실패(캐시로 유지): ${e?.message||'unknown'}`;
        }
      }

      // 3) 가짜 라이브 시작(완성 봉을 캐시에 write-behind)
      startPseudoLive(data, pair, tf, cacheKey, limit);
    }

    function resetChart(){
      stopPseudoLive();
      try{ if(resizeObs){ resizeObs.disconnect(); resizeObs=null; } }catch{}
      try{ chart?.remove?.(); }catch{}
      chart=null; candleSeries=null;
    }

    // ====== 부트스트랩 ======
    document.addEventListener('DOMContentLoaded', async ()=>{
      const pairEl=$('pair');
      const tfWrap=$('tf-inside');

      try{ await window.__loadLwc(); }
      catch(e){ $('status').textContent='차트 라이브러리를 불러오지 못했습니다.\n→ 네트워크 또는 CDN 404'; console.error(e); return; }

      const State={ pair: pairEl.value, tf: (tfWrap.querySelector('.tf-btn.active')?.dataset.tf)||'1m' };
      tfWrap.querySelectorAll('.tf-btn').forEach(b=> b.classList.toggle('active', b.dataset.tf===State.tf));

      await loadChart(State.pair, State.tf).catch(err=>{ $('status').textContent=`에러: ${err.message}`; console.error(err); });

      tfWrap.addEventListener('click', async (e)=>{
        const btn=e.target.closest('button[data-tf]'); if(!btn) return;
        if(btn.classList.contains('active')) return;
        tfWrap.querySelectorAll('.tf-btn').forEach(b=>b.classList.remove('active'));
        btn.classList.add('active');
        State.tf=btn.dataset.tf;
        resetChart();
        await loadChart(State.pair, State.tf).catch(err=>{ $('status').textContent=`에러: ${err.message}`; console.error(err); });
      });

      pairEl.addEventListener('change', async ()=>{
        State.pair=pairEl.value;
        resetChart();
        await loadChart(State.pair, State.tf).catch(err=>{ $('status').textContent=`에러: ${err.message}`; console.error(err); });
      });
    });
</script>
</body>
</html>
