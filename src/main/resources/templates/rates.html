<!doctype html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="utf-8" />
    <title>환율 캔들 차트 (rates)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        :root {
          --bg: #0f1226; --fg: #e8ecff; --muted: #9aa3c7; --panel: #171b34;
          --accent: #6aa6ff; --good: #26a69a; --bad: #ef5350; --border: #2a2f55;
        }
        * { box-sizing: border-box; }
        body { margin:20px; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial; color:var(--fg); background:var(--bg); }
        h1 { margin:0 0 12px; font-weight:800; }
        .wrap { max-width:1100px; }
        .toolbar {
          display:flex; gap:12px; flex-wrap:wrap; align-items:center;
          background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:10px 12px; margin-bottom:12px;
        }
        .toolbar select, .toolbar input {
          background:#0d1126; color:var(--fg); border:1px solid #2b2f52; border-radius:8px; padding:8px;
        }
        .btn-group { display:inline-flex; border:1px solid var(--border); border-radius:10px; overflow:hidden; background:#121735; }
        .btn-group button { border:0; background:transparent; color:var(--muted); padding:8px 10px; cursor:pointer; font-weight:700; }
        .btn-group button + button { border-left:1px solid var(--border); }
        .btn-group button.active { background:var(--accent); color:#fff; }
        .status { font-size:13px; color:var(--muted); margin-left:auto; }
        .chart-card { background:#0b1020; border:1px solid #1b2144; border-radius:12px; padding:12px; }
        #chart { width:100%; height:560px; }
        .error { color:#ff8b8b; background:#2a0f14; border:1px solid #611b23; padding:10px; border-radius:8px; margin-top:10px; white-space:pre-wrap; display:none; }
    </style>
</head>
<body>
<div class="wrap">
    <h1>환율 캔들 차트</h1>

    <div class="toolbar">
        <label>
            <span style="font-weight:700; margin-right:6px;">종목</span>
            <select id="pair">
                <option value="USD/KRW" selected>USD/KRW</option>
                <option value="USD/JPY">USD/JPY</option>
                <option value="EUR/USD">EUR/USD</option>
                <option value="GBP/USD">GBP/USD</option>
            </select>
        </label>

        <div class="btn-group" id="tfButtons" role="group" aria-label="timeframe">
            <button type="button" data-tf="1m">1분</button>
            <button type="button" data-tf="30m">30분</button>
            <button type="button" data-tf="1h" class="active">1시간</button>
            <button type="button" data-tf="4h">4시간</button>
            <button type="button" data-tf="1d">1일</button>
            <button type="button" data-tf="1w">1주</button>
            <button type="button" data-tf="1M">1개월</button>
        </div>

        <label>
            <span style="font-weight:700; margin-right:6px;">갯수</span>
            <input id="limit" type="number" min="50" step="10" value="240" style="width:100px;" />
        </label>

        <label>
            <span style="font-weight:700; margin-right:6px;">자동갱신</span>
            <select id="refresh">
                <option value="auto" selected>자동</option>
                <option value="0">끔</option>
                <option value="3">3초</option>
                <option value="5">5초</option>
                <option value="10">10초</option>
                <option value="15">15초</option>
                <option value="30">30초</option>
                <option value="60">60초</option>
            </select>
        </label>

        <div id="status" class="status">대기 중</div>
    </div>

    <div class="chart-card">
        <div id="chart"></div>
        <div id="err" class="error"></div>
    </div>
</div>

<script>
    // ========= API BASE (8081에서 열면 8080으로 프록시) =========
    const API_BASE =
      (location.hostname === 'localhost' && location.port === '8081')
        ? 'http://localhost:8080'
        : '';

    // ========= DOM =========
    const $ = (id) => document.getElementById(id);
    const pairEl = $('pair'), limitEl = $('limit'), refreshEl = $('refresh');
    const statusEl = $('status'), errEl = $('err'), tfButtons = $('tfButtons'), chartEl = $('chart');

    function showErr(msg){ errEl.style.display='block'; errEl.textContent=msg; }
    function hideErr(){ errEl.style.display='none'; errEl.textContent=''; }

    // ========= 유틸 =========
    function toSeconds(t){
      if (typeof t === 'number') return Math.floor(t > 1e12 ? t/1000 : t);
      if (typeof t === 'string'){
        const n = Number(t);
        if (!Number.isNaN(n)) return toSeconds(n);
        const d = new Date(t); // 'YYYY-MM-DD HH:mm:ss'도 Chrome에서 파싱됨
        if (!isNaN(d)) return Math.floor(d.getTime()/1000);
      }
      return NaN;
    }
    function num(x){ const n = Number(x); return Number.isFinite(n)? n : NaN; }

    // ========= 차트(KST 표시) =========
    let chart, candleSeries, resizeObs, liveTimer=null;

    function kstTickFormatter(tsSec, tickType){
      const d = new Date(tsSec*1000);
      if (tickType==='Time'){
        return new Intl.DateTimeFormat('ko-KR',{ timeZone:'Asia/Seoul', hour12:false, hour:'2-digit', minute:'2-digit' }).format(d);
      }
      if (tickType==='Day'){
        return new Intl.DateTimeFormat('ko-KR',{ timeZone:'Asia/Seoul', month:'2-digit', day:'2-digit' }).format(d);
      }
      if (tickType==='Month'){
        return new Intl.DateTimeFormat('ko-KR',{ timeZone:'Asia/Seoul', year:'2-digit', month:'2-digit' }).format(d);
      }
      return new Intl.DateTimeFormat('ko-KR',{ timeZone:'Asia/Seoul', year:'numeric' }).format(d);
    }
    function kstCrosshairFormatter(time){
      const d = new Date(time*1000);
      const date = new Intl.DateTimeFormat('ko-KR',{ timeZone:'Asia/Seoul', year:'numeric', month:'2-digit', day:'2-digit' }).format(d);
      const hm = new Intl.DateTimeFormat('ko-KR',{ timeZone:'Asia/Seoul', hour12:false, hour:'2-digit', minute:'2-digit', second:'2-digit' }).format(d);
      return `${date} ${hm} (KST)`;
    }

    function initChart(){
      chart = LightweightCharts.createChart(chartEl, {
        width: chartEl.clientWidth, height: 560,
        layout:{ background:{ color:'#0b1020' }, textColor:'#e3e7ff', fontFamily:'ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,Arial' },
        rightPriceScale:{ borderVisible:false },
        timeScale:{ borderVisible:false, timeVisible:true, secondsVisible:true, tickMarkFormatter:(t,ty)=>kstTickFormatter(t,ty) },
        crosshair:{ mode: LightweightCharts.CrosshairMode.Normal },
        grid:{ vertLines:{ color:'rgba(255,255,255,0.04)' }, horzLines:{ color:'rgba(255,255,255,0.04)' } },
        localization:{ locale:'ko-KR', timeFormatter:(t)=>kstCrosshairFormatter(t) }
      });
      candleSeries = chart.addCandlestickSeries({
        upColor:'#26a69a', downColor:'#ef5350',
        wickUpColor:'#26a69a', wickDownColor:'#ef5350',
        borderUpColor:'#26a69a', borderDownColor:'#ef5350',
        priceLineVisible:true,
      });
      if (window.ResizeObserver){
        resizeObs = new ResizeObserver(()=>chart.applyOptions({ width: chartEl.clientWidth }));
        resizeObs.observe(chartEl);
      }else{
        window.addEventListener('resize', ()=>chart.applyOptions({ width: chartEl.clientWidth }));
      }
    }

    // ========= 데이터 =========
    async function fetchCandles(pair, tf, limit){
      const qs = new URLSearchParams({ pair: pair.trim(), tf: tf.trim(), limit: String(limit) });
      const url = `${API_BASE}/api/td-candles?${qs}`;
      const res = await fetch(url, { mode: API_BASE ? 'cors' : 'same-origin' });
      const text = await res.text();
      if (!res.ok) throw new Error(text || `HTTP ${res.status}`);
      try { return JSON.parse(text); } catch { throw new Error('서버 응답이 JSON이 아닙니다.'); }
    }

    // ★★★ 핵심 수정: 배열로 감싼 {values:[]} 형태도 평탄화해서 처리 ★★★
    function normalizeCandles(raw){
      let arr = [];
      if (Array.isArray(raw)){
        // [ { values:[...], ... } ] → values만 펼치기
        if (raw.length && raw.every(x => x && Array.isArray(x.values))){
          arr = raw.flatMap(x => x.values);
        } else {
          arr = raw;
        }
      } else if (raw && Array.isArray(raw.values)){
        arr = raw.values;
      } else if (raw && Array.isArray(raw.data)){
        arr = raw.data;
      }

      const out = arr.map(c => {
        const t = c.time ?? c.timestamp ?? c.datetime ?? c.date;
        const open  = num(c.open  ?? c.o);
        const high  = num(c.high  ?? c.h);
        const low   = num(c.low   ?? c.l);
        const close = num(c.close ?? c.c);
        const ts = toSeconds(t);
        return { time: ts, open, high, low, close };
      }).filter(x =>
        Number.isFinite(x.time) && Number.isFinite(x.open) &&
        Number.isFinite(x.high) && Number.isFinite(x.low) &&
        Number.isFinite(x.close)
      ).sort((a,b) => a.time - b.time);

      return out;
    }

    async function loadChart(pair, tf, limit){
      hideErr();
      statusEl.textContent = `로딩 중… ${pair} / ${tf}`;
      try{
        const raw = await fetchCandles(pair, tf, limit);
        const candles = normalizeCandles(raw);
        if (!candles.length) throw new Error('표시할 캔들이 없습니다(응답 형식 또는 값 확인).');
        candleSeries.setData(candles);
        chart.timeScale().fitContent();
        statusEl.textContent = `불러옴: ${pair} / ${tf} / ${candles.length}개`;
      }catch(e){
        console.error(e);
        showErr(String(e.message || e));
        statusEl.textContent = '에러';
      }
    }

    async function tickUpdate(pair, tf){
      try{
        const raw = await fetchCandles(pair, tf, 2);
        const candles = normalizeCandles(raw);
        if (!candles.length) return;
        candleSeries.update(candles[candles.length-1]);
      }catch(e){
        console.debug('live update error', e);
      }
    }

    // ========= 라이브 =========
    function defaultRefreshSec(tf){
      switch(tf){
        case '1m': return 3;
        case '30m': return 10;
        case '1h': return 30;
        case '4h': return 60;
        case '1d': return 180;
        case '1w': return 300;
        case '1M': return 600;
        default: return 10;
      }
    }
    function startLive(pair, tf){
      stopLive();
      const val = refreshEl.value;
      const sec = (val === 'auto') ? defaultRefreshSec(tf) : Number(val)||0;
      if (sec > 0){
        liveTimer = setInterval(()=>tickUpdate(pair, tf), sec*1000);
        statusEl.textContent += ` • 실시간 ${sec}s`;
      }
    }
    function stopLive(){ if (liveTimer) clearInterval(liveTimer); liveTimer=null; }

    // ========= 상태 & 이벤트 =========
    const State = { pair: pairEl.value, tf:'1h', limit: Number(limitEl.value)||240 };

    function setActiveTF(tf){
      [...tfButtons.querySelectorAll('button')].forEach(b => b.classList.toggle('active', b.dataset.tf === tf));
    }

    tfButtons.addEventListener('click', async (e)=>{
      const btn = e.target.closest('button[data-tf]'); if (!btn) return;
      const tf = btn.dataset.tf; if (State.tf === tf) return;
      State.tf = tf; setActiveTF(tf);
      stopLive(); await loadChart(State.pair, State.tf, State.limit); startLive(State.pair, State.tf);
    });

    pairEl.addEventListener('change', async ()=>{
      State.pair = pairEl.value;
      stopLive(); await loadChart(State.pair, State.tf, State.limit); startLive(State.pair, State.tf);
    });

    limitEl.addEventListener('change', async ()=>{
      State.limit = Math.max(50, Number(limitEl.value)||240);
      stopLive(); await loadChart(State.pair, State.tf, State.limit); startLive(State.pair, State.tf);
    });

    refreshEl.addEventListener('change', ()=> startLive(State.pair, State.tf));

    document.addEventListener('DOMContentLoaded', async ()=>{
      initChart();
      await loadChart(State.pair, State.tf, State.limit);
      startLive(State.pair, State.tf);
    });
</script>
</body>
</html>
