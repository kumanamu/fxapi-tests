<!doctype html>
<html lang="ko">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>KRW FX • Candles (Twelve Data, 70s)</title>
    <style>
        :root { color-scheme: dark; }
        body { margin:0; background:#0f1520; color:#e6e8eb; font-family:ui-sans-serif,-apple-system,Segoe UI,Roboto,Arial; }
        .top { display:flex; gap:10px; align-items:center; padding:10px 14px; background:#0b101a; border-bottom:1px solid #1d2430; }
        .top .spacer{ flex:1 }
        .hud { display:flex; gap:10px; align-items:center; font-size:14px; }
        .hud .lab{ opacity:.7 }
        .wrap { padding:14px; display:grid; gap:10px; }
        .panel { background:#0b101a; border:1px solid #1d2430; border-radius:12px; padding:10px; }
        #tv { width:100%; height:540px; }
        select,button{ background:#141a26; color:#e6e8eb; border:1px solid #222a39; border-radius:8px; padding:6px 10px; }
        .tag { padding:3px 8px; border-radius:999px; border:1px solid #2a3750; background:#121a28; font-size:12px; }
        .note{ opacity:.8; font-size:12px; }
        .debug{ font-family:ui-monospace,Menlo,Consolas,monospace; line-height:1.35; }
        .bad { color:#ff7b7b; }
        .ok { color:#9be39b; }
    </style>
</head>
<body>
<div class="top">
    <strong>KRW FX</strong>
    <select id="pair">
        <option>USD-KRW</option><option>JPY-KRW</option>
        <option>CNY-KRW</option><option>GBP-KRW</option><option>EUR-KRW</option>
    </select>
    <select id="tf">
        <option value="1m">1m</option>
        <option value="5m">5m</option><option value="15m">15m</option>
        <option value="30m" selected>30m</option><option value="60m">1h</option>
        <option value="1d">1D</option><option value="1mo">1M</option><option value="1y">1Y</option>
    </select>
    <button id="reload">Reload</button>
    <span id="src" class="tag">—</span>
    <div class="spacer"></div>
    <!-- HUD -->
    <div class="hud" id="hud">
        <span class="lab">현재가</span><strong id="pLast">—</strong>
        <span class="lab">O</span><span id="pO">—</span>
        <span class="lab">H</span><span id="pH">—</span>
        <span class="lab">L</span><span id="pL">—</span>
        <span class="lab">C</span><span id="pC">—</span>
    </div>
</div>

<div class="wrap">
    <div class="panel"><div id="tv"></div></div>
    <div class="panel note debug">
        <div id="status">ready…</div>
        <div>url: <span id="dbgUrl">—</span></div>
        <div>http: <span id="dbgHttp">—</span> • bars: <span id="dbgLen">—</span></div>
    </div>
</div>
<script>
    // ?api=http://localhost:8081 쿼리로 오버라이드 가능
    const API_BASE = new URLSearchParams(location.search).get('api') || '';
    // ... 아래 fetch 에서 `${API_BASE}` 프리픽스만 붙이면 끝
</script>

<!-- TradingView lightweight-charts -->
<script src="https://unpkg.com/lightweight-charts@4.2.1/dist/lightweight-charts.standalone.production.js"></script>

<script>
    const $ = id => document.getElementById(id);
    const numfmt = new Intl.NumberFormat('ko-KR', { maximumFractionDigits: 6 });
    const setNum = (id, v) => { const el=$(id); if (el) el.textContent = Number.isFinite(v) ? numfmt.format(v) : String(v); };
    const setText= (id, v) => { const el=$(id); if (el) el.textContent = String(v); };

    // 70초 주기
    const REFRESH_MS = 70_000;
    const RATE_LIMIT_COOLDOWN = 70_000;

    let chart, candle, timer, lastBar;

    function ensureChart(){
      if (chart) return;
      const el = $('tv');
      chart = LightweightCharts.createChart(el, {
        layout:{ background:{ color:'#0f1520' }, textColor:'#e6e8eb' },
        grid:{ vertLines:{ color:'rgba(255,255,255,.06)' }, horzLines:{ color:'rgba(255,255,255,.06)' } },
        rightPriceScale:{ borderVisible:false },
        timeScale:{ borderVisible:false, secondsVisible:false },
        crosshair:{ mode: LightweightCharts.CrosshairMode.Normal },
        localization:{ priceFormatter: p => numfmt.format(p) },
      });
      candle = chart.addCandlestickSeries({
        upColor:'#22d3ee', downColor:'#f87171',
        wickUpColor:'#22d3ee', wickDownColor:'#f87171',
        borderVisible:false
      });

      const ro = new ResizeObserver(()=>{
        const w = el.clientWidth, h = el.clientHeight;
        chart.applyOptions({ width:w, height:h });
        chart.timeScale().fitContent();        // ✅ 리사이즈 후 가시영역 보정
      });
      ro.observe(el);

      // 초기 사이즈 적용 + 보정
      chart.applyOptions({ width:el.clientWidth, height:el.clientHeight });
      chart.timeScale().fitContent();

      chart.subscribeCrosshairMove(param=>{
        const v = param?.seriesData?.get?.(candle);
        if (v && v.open!==undefined) {
          setNum('pLast', v.close); setNum('pO', v.open); setNum('pH', v.high); setNum('pL', v.low); setNum('pC', v.close);
        } else if (lastBar) {
          setNum('pLast', lastBar.close); setNum('pO', lastBar.open); setNum('pH', lastBar.high); setNum('pL', lastBar.low); setNum('pC', lastBar.close);
        }
      });
    }

    function normalize(points){
      const arr = Array.isArray(points) ? points.slice() : [];
      // Twelve Data는 "YYYY-MM-DD HH:mm:ss" 형태. 로컬 파싱이므로 브라우저별 차이를 줄이려면 'YYYY-MM-DDTHH:mm:ss' 로 치환해도 됨.
      arr.forEach(p => {
        const iso = String(p.t).replace(' ', 'T'); // ✅ 파싱 안정성 보강
        p._ts = new Date(iso).getTime();
      });
      arr = arr.filter(p => Number.isFinite(p._ts));
      arr.sort((a,b)=>a._ts-b._ts);
      const seen=new Set(), out=[];
      for(const p of arr){ if(!seen.has(p._ts)){ out.push(p); seen.add(p._ts);} }
      return out;
    }
    const isIntraday = tf => ['1m','5m','15m','30m','60m'].includes(tf);
    const toTime = (t, tf) => {
      const d = new Date(String(t).replace(' ', 'T'));
      if (isIntraday(tf)) return Math.floor(d.getTime()/1000);
      return { year:d.getUTCFullYear(), month:d.getUTCMonth()+1, day:d.getUTCDate() };
    };

    function toCandles(points, tf){
      const rows = normalize(points);
      if (!rows.length) return [];
      const out = rows.map(p=>{
        const o=+p.o, h=+p.h, l=+p.l, c=+p.c;
        return { time:toTime(p.t,tf), open:o, high:h, low:l, close:c };
      }).filter(b=>[b.open,b.high,b.low,b.close].every(Number.isFinite));
      return out;
    }

    async function fetchCandles(pair, tf, limit=240){
      const url = `/api/candles-td?pair=${encodeURIComponent(pair)}&tf=${tf}&limit=${limit}`;
      setText('dbgUrl', url);
      try{
        const r = await fetch(url, { cache:'no-store' });
        setText('dbgHttp', `${r.status} ${r.statusText}`);
        const data = await r.json().catch(()=>({}));
        return { ok:r.ok, status:r.status, data };
      }catch(e){
        setText('dbgHttp', `fetch error`);
        return { ok:false, status:0, data:null };
      }
    }
    async function fetchQuote(pair){
      const url = `/api/quote-td?pair=${encodeURIComponent(pair)}`;
      try{
        const r = await fetch(url, { cache:'no-store' });
        if (!r.ok) return null;
        return await r.json();
      }catch{ return null; }
    }

    function draw(bars, pair, tf, source){
      ensureChart();
      candle.setData(bars);
      chart.timeScale().fitContent();                 // ✅ 데이터 세팅 후 가시영역 보정
      setText('src', source || '—');
      setText('dbgLen', bars.length);
      setText('status', `ok • ${new Date().toLocaleTimeString()} • ${pair} ${tf} • bars=${bars.length}`);
      const last = bars[bars.length-1];
      if (last){
        lastBar = last;
        setNum('pLast', last.close);
        setNum('pO', last.open); setNum('pH', last.high); setNum('pL', last.low); setNum('pC', last.close);
      }
    }

    async function reload(){
      clearTimeout(timer);
      const pair = $('pair')?.value ?? 'USD-KRW';
      const tf   = $('tf')?.value   ?? '30m';
      const res = await fetchCandles(pair, tf, tf==='1y'?365:240);

      if (res.ok && res?.data?.points) {
        const bars = toCandles(res.data.points, tf);
        if (bars.length === 0) {
          setText('status', '데이터 없음(0 bars)'); $('status').className='bad';
        } else {
          draw(bars, pair, tf, res.data.source); $('status').className='ok';
          // 현재가 보정
          const q = await fetchQuote(pair);
          if (q && Number.isFinite(q.last)) setNum('pLast', q.last);
        }
        timer = setTimeout(reload, REFRESH_MS);
        return;
      }

      if (res.status === 429) {
        setText('status', '요청 제한(429): 무료 키 호출 한도 초과. 70초 후 자동 재시도합니다.'); $('status').className='bad';
        timer = setTimeout(reload, RATE_LIMIT_COOLDOWN);
        return;
      }

      setText('status', '에러: ' + (res.status || 'network')); $('status').className='bad';
      timer = setTimeout(reload, REFRESH_MS);
    }

    $('reload').addEventListener('click', reload);
    $('pair').addEventListener('change', reload);
    $('tf').addEventListener('change', reload);
    window.addEventListener('load', reload);
</script>
</body>
</html>
