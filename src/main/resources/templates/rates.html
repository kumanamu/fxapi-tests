<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>KRW 기준 환율</title>
    <style>
        :root{--bg:#0B1221;--panel:#0F172A;--text:#D1D5DB;--muted:#9CA3AF;--up:#10B981;--down:#EF4444;--grid:rgba(255,255,255,.06);--accent:#2563EB}
        html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
        .wrap{display:grid;grid-template-columns:320px 1fr;gap:16px;height:100%;box-sizing:border-box;padding:16px}
        .panel{background:var(--panel);border-radius:16px;padding:16px;display:flex;flex-direction:column;gap:16px;box-shadow:0 6px 24px rgba(0,0,0,.2)}
        .panel h2{margin:0 0 8px;font-size:18px}
        .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
        label{font-size:12px;color:var(--muted)}
        select{background:#0b1221;color:var(--text);border:1px solid #1F2937;border-radius:10px;padding:8px 10px;outline:none;width:100%}
        .chart-card{background:var(--panel);border-radius:16px;padding:12px;height:100%;display:flex;flex-direction:column;box-shadow:0 6px 24px rgba(0,0,0,.2);position:relative}
        #chart-area{flex:1;min-height:560px;border-radius:12px;position:relative}
        #status{font-size:12px;color:var(--muted);margin-top:6px;min-height:16px;white-space:pre-line}
        .pair-title{font-size:16px;font-weight:600;display:flex;align-items:baseline;gap:8px}
        .last-quote{font-size:14px}
        .hint{font-size:12px;color:var(--muted)}
        .divider{height:1px;background:#1F2937;margin:8px 0}
        .tf-inside{position:absolute;left:16px;top:16px;display:flex;gap:6px;z-index:10;background:rgba(11,18,33,.6);backdrop-filter:blur(6px);padding:6px;border-radius:12px;border:1px solid #1F2937}
        .tf-btn{background:#111827;color:var(--text);border:1px solid #1F2937;border-radius:999px;padding:6px 10px;cursor:pointer;font-size:12px}
        .tf-btn.active{border-color:var(--accent);box-shadow:0 0 0 2px rgba(37,99,235,.25) inset}
        @media (max-width:900px){.wrap{grid-template-columns:1fr}}
    </style>

    <!-- Lightweight Charts 폴백 로더 -->
    <script>
        (function () {
          const cdn = (v, f) => `https://cdn.jsdelivr.net/npm/lightweight-charts@${v}/dist/${f}`;
          const unp = (v, f) => `https://unpkg.com/lightweight-charts@${v}/dist/${f}`;
          const versions = ["4.3.0","4"];
          const files = [
            "lightweight-charts.standalone.production.min.js",
            "lightweight-charts.standalone.production.js",
            "lightweight-charts.standalone.development.js",
          ];
          const candidates = [];
          versions.forEach(v => files.forEach(f => candidates.push(cdn(v,f))));
          versions.forEach(v => files.forEach(f => candidates.push(unp(v,f))));
          window.__loadLwc = () =>
            new Promise((resolve, reject) => {
              let i=0;
              const tryNext=()=>{
                if(i>=candidates.length) return reject(new Error("Lightweight Charts 로드 실패"));
                const url=candidates[i++], s=document.createElement("script");
                s.src=url; s.async=true;
                s.onload=()=>{
                  const L=window.LightweightCharts;
                  if(!L?.createChart){ s.remove(); tryNext(); return; }
                  const tmp=document.createElement("div"); document.body.appendChild(tmp);
                  try{
                    const c=L.createChart(tmp);
                    if(typeof c?.addCandlestickSeries!=="function"){ s.remove(); c?.remove?.(); tmp.remove(); tryNext(); return; }
                    c.remove(); tmp.remove(); resolve();
                  }catch{ s.remove(); tmp.remove(); tryNext(); }
                };
                s.onerror=tryNext; document.head.appendChild(s);
              };
              tryNext();
            });
        })();
    </script>
</head>
<body>
<div class="wrap">
    <aside class="panel">
        <div>
            <h2>설정</h2>
            <div class="row" style="margin-top:8px;">
                <div style="display:flex;flex-direction:column;gap:6px;min-width:100%;">
                    <label for="pair">통화 쌍 (기준단위 → KRW)</label>
                    <select id="pair">
                        <option value="USD/KRW" selected>원달러환율 (1 USD → KRW)</option>
                        <option value="JPY/KRW">원엔화환율 (100 JPY → KRW)</option>
                        <option value="CNY/KRW">원위안환율 (100 CNY → KRW)</option>
                        <option value="EUR/KRW">원유로환율 (1 EUR → KRW)</option>
                        <option value="GBP/KRW">원파운드환율 (1 GBP → KRW)</option>
                    </select>
                </div>
            </div>

            <div class="divider"></div>
            <div class="pair-title">
                <span id="pair-label">원달러환율 (USD/KRW)</span>
                <span class="last-quote" id="last-quote"></span>
            </div>
            <div class="hint">※ 백엔드는 <b>XXX/KRW</b>로 조회합니다. 엔/위안은 <b>100 단위</b>로 환산하여 표시합니다.</div>
            <div id="status"></div>
        </div>
    </aside>

    <main class="chart-card">
        <div id="chart-area">
            <div class="tf-inside" id="tf-inside">
                <button class="tf-btn" data-tf="1s">1초</button>
                <button class="tf-btn active" data-tf="1m">1분</button>
                <button class="tf-btn" data-tf="15m">15분</button>
                <button class="tf-btn" data-tf="30m">30분</button>
                <button class="tf-btn" data-tf="1h">1시간</button>
                <button class="tf-btn" data-tf="4h">4시간</button>
                <button class="tf-btn" data-tf="1d">1일</button>
                <button class="tf-btn" data-tf="1w">1주</button>
                <button class="tf-btn" data-tf="1M">1개월</button>
            </div>
        </div>
    </main>
</div>

<script>
    // ===== 전역 & 설정 =====
    let chart, candleSeries, resizeObs, pseudoTimer=null;
    const $ = (id) => document.getElementById(id);

    // 페어별 기준 단위
    const PAIR_CFG = {
      'USD/KRW': { title:'원달러환율',  basis:1,   basisLabel:'1 USD',  seed:1350 },
      'JPY/KRW': { title:'원엔화환율',  basis:100, basisLabel:'100 JPY', seed:900  },
      'CNY/KRW': { title:'원위안환율',  basis:100, basisLabel:'100 CNY', seed:19000},
      'EUR/KRW': { title:'원유로환율',  basis:1,   basisLabel:'1 EUR',  seed:1450 },
      'GBP/KRW': { title:'원파운드환율', basis:1,   basisLabel:'1 GBP',  seed:1750 },
    };

    // 자동 limit
    const AUTO_LIMIT = (tf) => ({
      '1s': 900,
      '1m': 720,
      '15m':800,
      '30m':800,
      '1h': 900,
      '4h': 800,
      '1d': 1000,
      '1w': 800,
      '1M': 600
    }[tf] ?? 900);

    // ===== 포맷/시간 =====
    const PRICE_PREC = 2;
    const minMoveFor = (p)=> Math.pow(10,-p);
    const fmt2 = (n)=> {
      try { return Number(n).toLocaleString(undefined,{minimumFractionDigits:PRICE_PREC,maximumFractionDigits:PRICE_PREC}); }
      catch { return String(n); }
    };

    const KST_OFFSET = 9*3600; // seconds
    const toKstSec = (utcSec)=> utcSec + KST_OFFSET;
    const toUtcSec = (kstSec)=> kstSec - KST_OFFSET;

    function tickMarkKSTFormatterFactory(currentTf) {
      return (time) => {
        const d = new Date((time + KST_OFFSET) * 1000);
        const y = d.getUTCFullYear();
        const M = String(d.getUTCMonth()+1).padStart(2,'0');
        const D = String(d.getUTCDate()).padStart(2,'0');
        const h = String(d.getUTCHours()).padStart(2,'0');
        const m = String(d.getUTCMinutes()).padStart(2,'0');
        const s = String(d.getUTCSeconds()).padStart(2,'0');
        if (currentTf === '1s') return `${h}:${m}:${s}`;
        if (currentTf === '1m' || currentTf === '15m' || currentTf === '30m' || currentTf === '1h' || currentTf==='4h') return `${M}/${D} ${h}:${m}`;
        if (currentTf === '1w' || currentTf === '1M') return `${y}-${M}-${D}`;
        return `${y}-${M}-${D}`;
      };
    }

    const TF_UNIT_SEC = (tf) => ({
      '1s':1, '1m':60, '15m':900, '30m':1800, '1h':3600, '4h':14400
    }[tf] ?? null);

    function floorToTfStartKst(kstSec, tf) {
      const unit = TF_UNIT_SEC(tf);
      if (unit) return kstSec - (kstSec % unit);

      const dayStart = kstSec - (kstSec % 86400);
      if (tf === '1d') return dayStart;

      if (tf === '1w') {
        const dow = new Date((toUtcSec(kstSec))*1000).getUTCDay(); // 0=일..6=토
        const daysFromMon = (dow + 6) % 7; // 월=0
        return dayStart - daysFromMon*86400;
      }

      if (tf === '1M') {
        const k = new Date((toUtcSec(kstSec))*1000);
        const y = k.getUTCFullYear();
        const m = k.getUTCMonth();
        const firstOfMonthKst = Date.UTC(y, m, 1, 0,0,0) + KST_OFFSET*1000;
        return Math.floor(firstOfMonthKst/1000);
      }
      return kstSec;
    }

    function nextTfStartKst(fromKstStart, tf) {
      const unit = TF_UNIT_SEC(tf);
      if (unit) return fromKstStart + unit;

      if (tf === '1d') return fromKstStart + 86400;
      if (tf === '1w') return fromKstStart + 7*86400;
      if (tf === '1M') {
        const k = new Date((toUtcSec(fromKstStart))*1000);
        const y = k.getUTCFullYear();
        const m = k.getUTCMonth();
        const next = Date.UTC(m===11?y+1:y, (m+1)%12, 1, 0,0,0) + KST_OFFSET*1000;
        return Math.floor(next/1000);
      }
      return fromKstStart;
    }

    // ===== 백엔드 tf 매핑 & 재시도 =====
    const TF_BACKEND = {
      '1s': ['1m'],                 // 1초봉 → 1분 시드
      '1m': ['1m','60'],
      '15m':['15m'],
      '30m':['30m'],
      '1h': ['1h','60m'],
      '4h': ['4h','240m'],
      '1d': ['1day','1d','D','day'],
      '1w': ['1week','1w','W','week'],
      '1M': ['1month','1M','M','month'],
    };

    async function fetchCandlesFromBackend(apiPair, tf, limit) {
      const tried = [];
      const limitPlan = [Math.min(limit, 900), 480, 240, 120].filter((v,i,a)=>v>0 && a.indexOf(v)===i);
      const tfCandidates = TF_BACKEND[tf] ?? [tf];

      let lastErr = null;
      for (const lc of limitPlan) {
        for (const t of tfCandidates) {
          tried.push(`${t}/${lc}`);
          try {
            const url = `/api/td-candles?pair=${encodeURIComponent(apiPair)}&tf=${encodeURIComponent(t)}&limit=${lc}`;
            const res = await fetch(url);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const body = await res.json();
            const vals = Array.isArray(body?.values) ? body.values : [];
            if (vals.length) return vals;
            lastErr = new Error('empty');
          } catch (e) {
            lastErr = e;
          }
        }
      }
      const statusEl = $('status');
      if (statusEl) statusEl.textContent = `백엔드 오류(가상 시드로 전환): ${lastErr?.message||'fetch fail'}\n시도: ${tried.join(', ')}`;
      throw lastErr || new Error('fetch failed');
    }

    // ===== 파싱/스케일 =====
    function parseCandles(values){
      return values.map(it=>{
        const t=(it.datetime||it.date||it.time);
        const utcSec = Math.floor(new Date((t && t.endsWith('Z')) ? t : (t+'Z')).getTime()/1000);
        return { time: utcSec, open:+it.open, high:+it.high, low:+it.low, close:+it.close };
      });
    }

    function applyBasis(cs, units){
      if(units===1) return cs;
      return cs.map(c=>({ time:c.time,
        open:c.open*units, high:c.high*units, low:c.low*units, close:c.close*units }));
    }

    // ===== 가상 시드 히스토리 생성(백엔드 실패 대비) =====
    function volatilityFor(tf){
      return ({
        '1s': 0.00020, '1m':0.00015, '15m':0.00025, '30m':0.00030,
        '1h': 0.00040, '4h':0.00060, '1d':0.00120, '1w':0.00200, '1M':0.00350
      }[tf] ?? 0.0003);
    }

    function buildSyntheticHistory(startPrice, tf, bars){
      const out = [];
      const nowKst = Math.floor(Date.now()/1000) + KST_OFFSET;
      const endKst = floorToTfStartKst(nowKst, tf); // 현재 진행중 봉의 시작
      const unit = TF_UNIT_SEC(tf) || (tf==='1d'?86400:(tf==='1w'?7*86400:(tf==='1M'?2629800:60)));

      const sigma = Math.max(startPrice * volatilityFor(tf), 0.01);
      // 과거로 bars-1개 생성
      let close = startPrice;
      for (let i=bars-1; i>=0; i--){
        const tKst = endKst - i*unit;
        const tUtc = toUtcSec(tKst);
        const open = close;
        // 이전 변동에서 약간씩 노이즈
        const step = (Math.random()*2-1)*sigma;
        close = Math.max(0.01, open + step);
        const high = Math.max(open, close) + Math.random()*sigma*0.5;
        const low  = Math.min(open, close) - Math.random()*sigma*0.5;
        out.push({ time:tUtc, open, high, low, close });
      }
      return out;
    }

    // ===== 차트 보일러플레이트 =====
    function ensureChart(currentTf){
      const L=window.LightweightCharts, statusEl=$('status');
      if(!L?.createChart){ statusEl.textContent='LightweightCharts 로드 실패'; return false; }
      if(!chart){
        const cont=$('chart-area');
        chart=L.createChart(cont,{
          layout:{ textColor:'#D1D5DB', background:{ type:'solid', color:'#0B1221' } },
          grid:{ vertLines:{ color:'rgba(255,255,255,0.06)' }, horzLines:{ color:'rgba(255,255,255,0.06)' } },
          timeScale:{
            timeVisible:true,
            secondsVisible: currentTf === '1s',
            borderVisible:false,
            tickMarkFormatter: tickMarkKSTFormatterFactory(currentTf),
          },
          rightPriceScale:{ borderVisible:false },
          crosshair:{ mode:0 },
          localization: { locale: 'ko-KR' },
        });
      } else {
        chart.applyOptions({
          timeScale:{
            timeVisible:true,
            secondsVisible: currentTf === '1s',
            borderVisible:false,
            tickMarkFormatter: tickMarkKSTFormatterFactory(currentTf),
          },
        });
      }
      if(!candleSeries){
        candleSeries=chart.addCandlestickSeries({
          upColor:'#10B981', downColor:'#EF4444',
          borderUpColor:'#10B981', borderDownColor:'#EF4444',
          wickUpColor:'#10B981', wickDownColor:'#EF4444',
          priceFormat:{ type:'price', precision:PRICE_PREC, minMove:minMoveFor(PRICE_PREC) }
        });
      } else {
        candleSeries.applyOptions({ priceFormat:{ type:'price', precision:PRICE_PREC, minMove:minMoveFor(PRICE_PREC) } });
      }
      if(!resizeObs){
        const cont=$('chart-area');
        resizeObs=new ResizeObserver(()=>{ try{ chart.timeScale().fitContent(); }catch{} });
        resizeObs.observe(cont);
      }
      return true;
    }

    function stopPseudoLive(){ if(pseudoTimer){ clearInterval(pseudoTimer); pseudoTimer=null; } }

    // ===== 가짜 라이브 엔진 =====
    function startPseudoLive(seedData, pair, tf){
      stopPseudoLive();
      if(!seedData?.length || !candleSeries) return;

      const vol = volatilityFor(tf);
      const tickMs = (tf==='1s') ? 250 : 1000;
      const cfg = PAIR_CFG[pair] || { basisLabel:'기준' };

      const nowKst = Math.floor(Date.now()/1000) + KST_OFFSET;
      let curStartKst = floorToTfStartKst(nowKst, tf);
      let curStartUtc = toUtcSec(curStartKst);

      const lastSeed = seedData[seedData.length-1];
      if (lastSeed.time < curStartUtc) {
        const open = lastSeed.close;
        candleSeries.update({ time:curStartUtc, open, high:open, low:open, close:open });
      } else if (lastSeed.time > curStartUtc) {
        curStartUtc = lastSeed.time;
        curStartKst = toKstSec(curStartUtc);
      }

      let bar = { ...seedData[seedData.length-1] };
      if (bar.time < curStartUtc) {
        const o = seedData[seedData.length-1].close;
        bar = { time: curStartUtc, open:o, high:o, low:o, close:o };
      }
      let lastClose = bar.close;

      pseudoTimer=setInterval(()=> {
        try{
          let nowK = Math.floor(Date.now()/1000) + KST_OFFSET;
          let nextK = nextTfStartKst(curStartKst, tf);

          let loopGuard = 0;
          while (nowK >= nextK && loopGuard++ < 10) {
            const open = lastClose;
            curStartKst = nextK;
            curStartUtc = toUtcSec(curStartKst);
            bar = { time: curStartUtc, open, high: open, low: open, close: open };
            candleSeries.update(bar);
            nextK = nextTfStartKst(curStartKst, tf);
          }

          const sigma = Math.max(lastClose * vol, 0.01);
          const step = (Math.random()*2 - 1) * sigma;
          const close = Math.max(0.01, lastClose + step);
          const high  = Math.max(bar.high, close);
          const low   = Math.min(bar.low,  close);
          bar = { ...bar, close, high, low };
          candleSeries.update(bar);
          lastClose = close;

          $('last-quote').textContent = `${cfg.basisLabel} ≈ ${fmt2(bar.close)} KRW`;
          $('status').textContent = `실시간 표시(가상): ${pair} • ${tf}`;
        }catch{}
      }, tickMs);
    }

    // ===== 로드 & 전환 =====
    async function loadChart(pair, tf){
      const statusEl=$('status'), lastEl=$('last-quote'), labelEl=$('pair-label');
      const cfg=PAIR_CFG[pair]; if(!cfg){ statusEl.textContent='지원하지 않는 통화'; return; }

      labelEl.textContent=`${cfg.title} (${pair})`;
      statusEl.textContent='불러오는 중…'; lastEl.textContent='';

      if(!ensureChart(tf)) return;
      stopPseudoLive();

      const limit = AUTO_LIMIT(tf);

      let data;
      try {
        const raw = await fetchCandlesFromBackend(pair, tf, limit);
        const base = parseCandles(raw);           // UTC
        data = applyBasis(base, cfg.basis);       // 엔/위안 ×100
        if (!data.length) throw new Error('empty');
      } catch (e) {
        // === 백엔드 실패 → 가상 시드로 전환 ===
        const seedStart = cfg.seed || 1000;
        data = buildSyntheticHistory(seedStart, tf, Math.max(60, Math.min(limit, 600)));
        statusEl.textContent = `백엔드 오류 → 가상 데이터로 전환 (${e?.message||'unknown'})`;
      }

      candleSeries.setData(data);
      chart.timeScale().fitContent();

      const last=data[data.length-1].close;
      $('last-quote').textContent=`${cfg.basisLabel} ≈ ${fmt2(last)} KRW`;
      if (!statusEl.textContent.startsWith('백엔드 오류')) {
        statusEl.textContent=`완료: ${pair} • ${tf} • ${data.length}개`;
      }

      startPseudoLive(data, pair, tf);
    }

    function resetChart(){
      stopPseudoLive();
      try{ if(resizeObs){ resizeObs.disconnect(); resizeObs=null; } }catch{}
      try{ chart?.remove?.(); }catch{}
      chart=null; candleSeries=null;
    }

    document.addEventListener('DOMContentLoaded', async ()=>{
      const pairEl=$('pair');
      const tfWrap=$('tf-inside');

      try{ await window.__loadLwc(); }
      catch(e){ $('status').textContent='차트 라이브러리를 불러오지 못했습니다.\n→ 네트워크 또는 CDN 404'; console.error(e); return; }

      const State={ pair: pairEl.value, tf: (tfWrap.querySelector('.tf-btn.active')?.dataset.tf)||'1m' };
      tfWrap.querySelectorAll('.tf-btn').forEach(b=> b.classList.toggle('active', b.dataset.tf===State.tf));

      await loadChart(State.pair, State.tf).catch(err=>{ $('status').textContent=`에러: ${err.message}`; console.error(err); });

      tfWrap.addEventListener('click', async (e)=>{
        const btn=e.target.closest('button[data-tf]'); if(!btn) return;
        if(btn.classList.contains('active')) return;
        tfWrap.querySelectorAll('.tf-btn').forEach(b=>b.classList.remove('active'));
        btn.classList.add('active');
        State.tf=btn.dataset.tf;
        resetChart();
        await loadChart(State.pair, State.tf).catch(err=>{ $('status').textContent=`에러: ${err.message}`; console.error(err); });
      });

      pairEl.addEventListener('change', async ()=>{
        State.pair=pairEl.value;
        resetChart();
        await loadChart(State.pair, State.tf).catch(err=>{ $('status').textContent=`에러: ${err.message}`; console.error(err); });
      });
    });
</script>
</body>
</html>
